{
  "version": 3,
  "sources": ["../../node_modules/@bufbuild/connect-web/dist/esm/assert-fetch-api.js", "../../node_modules/@bufbuild/connect-web/dist/esm/connect-transport.js", "../../node_modules/@bufbuild/connect/dist/esm/protocol-grpc/validate-trailer.js", "../../node_modules/@bufbuild/connect/dist/esm/protocol-grpc-web/request-header.js", "../../node_modules/@bufbuild/connect/dist/esm/protocol-grpc/http-status.js", "../../node_modules/@bufbuild/connect/dist/esm/protocol-grpc-web/validate-response.js", "../../node_modules/@bufbuild/connect-web/dist/esm/grpc-web-transport.js"],
  "sourcesContent": ["// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Asserts that the fetch API is available.\n */\nexport function assertFetchApi() {\n    try {\n        new Headers();\n    }\n    catch (_) {\n        throw new Error(\"connect-web requires the fetch API. Are you running on an old version of Node.js? Node.js is not supported in Connect for Web - please stay tuned for Connect for Node.\");\n    }\n}\n", "// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nimport { Message, MethodIdempotency, MethodKind } from \"@bufbuild/protobuf\";\nimport { appendHeaders } from \"@bufbuild/connect\";\nimport { createClientMethodSerializers, createEnvelopeReadableStream, createMethodUrl, getJsonOptions, encodeEnvelope, runStreamingCall, runUnaryCall, } from \"@bufbuild/connect/protocol\";\nimport { endStreamFlag, endStreamFromJson, errorFromJson, requestHeader, trailerDemux, transformConnectPostToGetRequest, validateResponse, } from \"@bufbuild/connect/protocol-connect\";\nimport { assertFetchApi } from \"./assert-fetch-api.js\";\n/**\n * Create a Transport for the Connect protocol, which makes unary and\n * server-streaming methods available to web browsers. It uses the fetch\n * API to make HTTP requests.\n */\nexport function createConnectTransport(options) {\n    var _a;\n    assertFetchApi();\n    const useBinaryFormat = (_a = options.useBinaryFormat) !== null && _a !== void 0 ? _a : false;\n    return {\n        async unary(service, method, signal, timeoutMs, header, message) {\n            var _a;\n            const { serialize, parse } = createClientMethodSerializers(method, useBinaryFormat, options.jsonOptions, options.binaryOptions);\n            return await runUnaryCall({\n                interceptors: options.interceptors,\n                signal,\n                timeoutMs,\n                req: {\n                    stream: false,\n                    service,\n                    method,\n                    url: createMethodUrl(options.baseUrl, service, method),\n                    init: {\n                        method: \"POST\",\n                        credentials: (_a = options.credentials) !== null && _a !== void 0 ? _a : \"same-origin\",\n                        redirect: \"error\",\n                        mode: \"cors\",\n                    },\n                    header: requestHeader(method.kind, useBinaryFormat, timeoutMs, header),\n                    message,\n                },\n                next: async (req) => {\n                    var _a;\n                    const useGet = options.useHttpGet === true &&\n                        method.idempotency === MethodIdempotency.NoSideEffects;\n                    let body = null;\n                    if (useGet) {\n                        req = transformConnectPostToGetRequest(req, serialize(req.message), useBinaryFormat);\n                    }\n                    else {\n                        body = serialize(req.message);\n                    }\n                    const fetch = (_a = options.fetch) !== null && _a !== void 0 ? _a : globalThis.fetch;\n                    const response = await fetch(req.url, Object.assign(Object.assign({}, req.init), { headers: req.header, signal: req.signal, body }));\n                    const { isUnaryError, unaryError } = validateResponse(method.kind, response.status, response.headers);\n                    if (isUnaryError) {\n                        throw errorFromJson((await response.json()), appendHeaders(...trailerDemux(response.headers)), unaryError);\n                    }\n                    const [demuxedHeader, demuxedTrailer] = trailerDemux(response.headers);\n                    return {\n                        stream: false,\n                        service,\n                        method,\n                        header: demuxedHeader,\n                        message: useBinaryFormat\n                            ? parse(new Uint8Array(await response.arrayBuffer()))\n                            : method.O.fromJson((await response.json()), getJsonOptions(options.jsonOptions)),\n                        trailer: demuxedTrailer,\n                    };\n                },\n            });\n        },\n        async stream(service, method, signal, timeoutMs, header, input) {\n            var _a;\n            const { serialize, parse } = createClientMethodSerializers(method, useBinaryFormat, options.jsonOptions, options.binaryOptions);\n            function parseResponseBody(body, trailerTarget) {\n                return __asyncGenerator(this, arguments, function* parseResponseBody_1() {\n                    const reader = createEnvelopeReadableStream(body).getReader();\n                    let endStreamReceived = false;\n                    for (;;) {\n                        const result = yield __await(reader.read());\n                        if (result.done) {\n                            break;\n                        }\n                        const { flags, data } = result.value;\n                        if ((flags & endStreamFlag) === endStreamFlag) {\n                            endStreamReceived = true;\n                            const endStream = endStreamFromJson(data);\n                            if (endStream.error) {\n                                throw endStream.error;\n                            }\n                            endStream.metadata.forEach((value, key) => trailerTarget.set(key, value));\n                            continue;\n                        }\n                        yield yield __await(parse(data));\n                    }\n                    if (!endStreamReceived) {\n                        throw \"missing EndStreamResponse\";\n                    }\n                });\n            }\n            async function createRequestBody(input) {\n                if (method.kind != MethodKind.ServerStreaming) {\n                    throw \"The fetch API does not support streaming request bodies\";\n                }\n                const r = await input[Symbol.asyncIterator]().next();\n                if (r.done == true) {\n                    throw \"missing request message\";\n                }\n                return encodeEnvelope(0, serialize(r.value));\n            }\n            return await runStreamingCall({\n                interceptors: options.interceptors,\n                timeoutMs,\n                signal,\n                req: {\n                    stream: true,\n                    service,\n                    method,\n                    url: createMethodUrl(options.baseUrl, service, method),\n                    init: {\n                        method: \"POST\",\n                        credentials: (_a = options.credentials) !== null && _a !== void 0 ? _a : \"same-origin\",\n                        redirect: \"error\",\n                        mode: \"cors\",\n                    },\n                    header: requestHeader(method.kind, useBinaryFormat, timeoutMs, header),\n                    message: input,\n                },\n                next: async (req) => {\n                    var _a;\n                    const fetch = (_a = options.fetch) !== null && _a !== void 0 ? _a : globalThis.fetch;\n                    const fRes = await fetch(req.url, Object.assign(Object.assign({}, req.init), { headers: req.header, signal: req.signal, body: await createRequestBody(req.message) }));\n                    validateResponse(method.kind, fRes.status, fRes.headers);\n                    if (fRes.body === null) {\n                        throw \"missing response body\";\n                    }\n                    const trailer = new Headers();\n                    const res = Object.assign(Object.assign({}, req), { header: fRes.headers, trailer, message: parseResponseBody(fRes.body, trailer) });\n                    return res;\n                },\n            });\n        },\n    };\n}\n", "// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { findTrailerError } from \"./trailer-status.js\";\n/**\n * Validates a trailer for the gRPC and the gRPC-web protocol.\n * Throws a ConnectError if the trailer contains an error status.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function validateTrailer(trailer) {\n    const err = findTrailerError(trailer);\n    if (err) {\n        throw err;\n    }\n}\n", "// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { headerAcceptEncoding, headerContentType, headerEncoding, headerTimeout, headerXGrpcWeb, headerXUserAgent, } from \"./headers.js\";\nimport { contentTypeJson, contentTypeProto } from \"./content-type.js\";\n/**\n * Creates headers for a gRPC-web request.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function requestHeader(useBinaryFormat, timeoutMs, userProvidedHeaders) {\n    const result = new Headers(userProvidedHeaders !== null && userProvidedHeaders !== void 0 ? userProvidedHeaders : {});\n    // Note that we do not support the grpc-web-text format.\n    // https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md#protocol-differences-vs-grpc-over-http2\n    result.set(headerContentType, useBinaryFormat ? contentTypeProto : contentTypeJson);\n    result.set(headerXGrpcWeb, \"1\");\n    // Note that we do not strictly comply with gRPC user agents.\n    // We use \"connect-es/1.2.3\" where gRPC would use \"grpc-es/1.2.3\".\n    // See https://github.com/grpc/grpc/blob/c462bb8d485fc1434ecfae438823ca8d14cf3154/doc/PROTOCOL-HTTP2.md#user-agents\n    result.set(headerXUserAgent, \"connect-es/0.13.0\");\n    if (timeoutMs !== undefined) {\n        result.set(headerTimeout, `${timeoutMs}m`);\n    }\n    return result;\n}\n/**\n * Creates headers for a gRPC-web request with compression.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function requestHeaderWithCompression(useBinaryFormat, timeoutMs, userProvidedHeaders, acceptCompression, sendCompression) {\n    const result = requestHeader(useBinaryFormat, timeoutMs, userProvidedHeaders);\n    if (sendCompression != null) {\n        result.set(headerEncoding, sendCompression.name);\n    }\n    if (acceptCompression.length > 0) {\n        result.set(headerAcceptEncoding, acceptCompression.map((c) => c.name).join(\",\"));\n    }\n    return result;\n}\n", "// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { Code } from \"../code.js\";\n/**\n * Determine the gRPC-web error code for the given HTTP status code.\n * See https://github.com/grpc/grpc/blob/master/doc/http-grpc-status-mapping.md.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function codeFromHttpStatus(httpStatus) {\n    switch (httpStatus) {\n        case 400: // Bad Request\n            return Code.Internal;\n        case 401: // Unauthorized\n            return Code.Unauthenticated;\n        case 403: // Forbidden\n            return Code.PermissionDenied;\n        case 404: // Not Found\n            return Code.Unimplemented;\n        case 429: // Too Many Requests\n            return Code.Unavailable;\n        case 502: // Bad Gateway\n            return Code.Unavailable;\n        case 503: // Service Unavailable\n            return Code.Unavailable;\n        case 504: // Gateway Timeout\n            return Code.Unavailable;\n        default:\n            // 200 is UNKNOWN because there should be a grpc-status in case of truly OK response.\n            return Code.Unknown;\n    }\n}\n", "// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { ConnectError } from \"../connect-error.js\";\nimport { Code } from \"../code.js\";\nimport { headerEncoding, headerGrpcMessage, headerGrpcStatus, } from \"./headers.js\";\nimport { codeFromHttpStatus } from \"../protocol-grpc/http-status.js\";\nimport { findTrailerError } from \"../protocol-grpc/trailer-status.js\";\n/**\n * Validates response status and header for the gRPC-web protocol.\n *\n * Throws a ConnectError if the header contains an error status,\n * or if the HTTP status indicates an error.\n *\n * Returns an object that indicates whether a gRPC status was found\n * in the response header. In this case, clients can not expect a\n * trailer.\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function validateResponse(status, headers) {\n    var _a;\n    // For compatibility with the `grpc-web` package, we treat all HTTP status\n    // codes in the 200 range as valid, not just HTTP 200.\n    if (status >= 200 && status < 300) {\n        const err = findTrailerError(headers);\n        if (err) {\n            throw err;\n        }\n        return { foundStatus: headers.has(headerGrpcStatus) };\n    }\n    throw new ConnectError(decodeURIComponent((_a = headers.get(headerGrpcMessage)) !== null && _a !== void 0 ? _a : `HTTP ${status}`), codeFromHttpStatus(status), headers);\n}\n/**\n * Validates response status and header for the gRPC-web protocol.\n * This function is identical to validateResponse(), but also verifies\n * that a given encoding header is acceptable.\n *\n * Returns an object with the response compression, and a boolean\n * indicating whether a gRPC status was found in the response header\n * (in this case, clients can not expect a trailer).\n *\n * @private Internal code, does not follow semantic versioning.\n */\nexport function validateResponseWithCompression(acceptCompression, status, headers) {\n    const { foundStatus } = validateResponse(status, headers);\n    let compression;\n    const encoding = headers.get(headerEncoding);\n    if (encoding !== null && encoding.toLowerCase() !== \"identity\") {\n        compression = acceptCompression.find((c) => c.name === encoding);\n        if (!compression) {\n            throw new ConnectError(`unsupported response encoding \"${encoding}\"`, Code.InvalidArgument, headers);\n        }\n    }\n    return {\n        foundStatus,\n        compression,\n    };\n}\n", "// Copyright 2021-2023 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nimport { Message, MethodKind } from \"@bufbuild/protobuf\";\nimport { createClientMethodSerializers, createEnvelopeReadableStream, createMethodUrl, encodeEnvelope, runStreamingCall, runUnaryCall, } from \"@bufbuild/connect/protocol\";\nimport { requestHeader, trailerFlag, trailerParse, validateResponse, validateTrailer, } from \"@bufbuild/connect/protocol-grpc-web\";\nimport { assertFetchApi } from \"./assert-fetch-api.js\";\n/**\n * Create a Transport for the gRPC-web protocol. The protocol encodes\n * trailers in the response body and makes unary and server-streaming\n * methods available to web browsers. It uses the fetch API to make\n * HTTP requests.\n *\n * Note that this transport does not implement the grpc-web-text format,\n * which applies base64 encoding to the request and response bodies to\n * support reading streaming responses from an XMLHttpRequest.\n */\nexport function createGrpcWebTransport(options) {\n    var _a;\n    assertFetchApi();\n    const useBinaryFormat = (_a = options.useBinaryFormat) !== null && _a !== void 0 ? _a : true;\n    return {\n        async unary(service, method, signal, timeoutMs, header, message) {\n            var _a;\n            const { serialize, parse } = createClientMethodSerializers(method, useBinaryFormat, options.jsonOptions, options.binaryOptions);\n            return await runUnaryCall({\n                interceptors: options.interceptors,\n                signal,\n                timeoutMs,\n                req: {\n                    stream: false,\n                    service,\n                    method,\n                    url: createMethodUrl(options.baseUrl, service, method),\n                    init: {\n                        method: \"POST\",\n                        credentials: (_a = options.credentials) !== null && _a !== void 0 ? _a : \"same-origin\",\n                        redirect: \"error\",\n                        mode: \"cors\",\n                    },\n                    header: requestHeader(useBinaryFormat, timeoutMs, header),\n                    message,\n                },\n                next: async (req) => {\n                    var _a;\n                    const fetch = (_a = options.fetch) !== null && _a !== void 0 ? _a : globalThis.fetch;\n                    const response = await fetch(req.url, Object.assign(Object.assign({}, req.init), { headers: req.header, signal: req.signal, body: encodeEnvelope(0, serialize(req.message)) }));\n                    validateResponse(response.status, response.headers);\n                    if (!response.body) {\n                        throw \"missing response body\";\n                    }\n                    const reader = createEnvelopeReadableStream(response.body).getReader();\n                    let trailer;\n                    let message;\n                    for (;;) {\n                        const r = await reader.read();\n                        if (r.done) {\n                            break;\n                        }\n                        const { flags, data } = r.value;\n                        if (flags === trailerFlag) {\n                            if (trailer !== undefined) {\n                                throw \"extra trailer\";\n                            }\n                            // Unary responses require exactly one response message, but in\n                            // case of an error, it is perfectly valid to have a response body\n                            // that only contains error trailers.\n                            trailer = trailerParse(data);\n                            continue;\n                        }\n                        if (message !== undefined) {\n                            throw \"extra message\";\n                        }\n                        message = parse(data);\n                    }\n                    if (trailer === undefined) {\n                        throw \"missing trailer\";\n                    }\n                    validateTrailer(trailer);\n                    if (message === undefined) {\n                        throw \"missing message\";\n                    }\n                    return {\n                        stream: false,\n                        header: response.headers,\n                        message,\n                        trailer,\n                    };\n                },\n            });\n        },\n        async stream(service, method, signal, timeoutMs, header, input) {\n            var _a;\n            const { serialize, parse } = createClientMethodSerializers(method, useBinaryFormat, options.jsonOptions, options.binaryOptions);\n            function parseResponseBody(body, foundStatus, trailerTarget) {\n                return __asyncGenerator(this, arguments, function* parseResponseBody_1() {\n                    const reader = createEnvelopeReadableStream(body).getReader();\n                    if (foundStatus) {\n                        // A grpc-status: 0 response header was present. This is a \"trailers-only\"\n                        // response (a response without a body and no trailers).\n                        //\n                        // The spec seems to disallow a trailers-only response for status 0 - we are\n                        // lenient and only verify that the body is empty.\n                        //\n                        // > [...] Trailers-Only is permitted for calls that produce an immediate error.\n                        // See https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md\n                        if (!(yield __await(reader.read())).done) {\n                            throw \"extra data for trailers-only\";\n                        }\n                        return yield __await(void 0);\n                    }\n                    let trailerReceived = false;\n                    for (;;) {\n                        const result = yield __await(reader.read());\n                        if (result.done) {\n                            break;\n                        }\n                        const { flags, data } = result.value;\n                        if ((flags & trailerFlag) === trailerFlag) {\n                            if (trailerReceived) {\n                                throw \"extra trailer\";\n                            }\n                            trailerReceived = true;\n                            const trailer = trailerParse(data);\n                            validateTrailer(trailer);\n                            trailer.forEach((value, key) => trailerTarget.set(key, value));\n                            continue;\n                        }\n                        if (trailerReceived) {\n                            throw \"extra message\";\n                        }\n                        yield yield __await(parse(data));\n                        continue;\n                    }\n                    if (!trailerReceived) {\n                        throw \"missing trailer\";\n                    }\n                });\n            }\n            async function createRequestBody(input) {\n                if (method.kind != MethodKind.ServerStreaming) {\n                    throw \"The fetch API does not support streaming request bodies\";\n                }\n                const r = await input[Symbol.asyncIterator]().next();\n                if (r.done == true) {\n                    throw \"missing request message\";\n                }\n                return encodeEnvelope(0, serialize(r.value));\n            }\n            return runStreamingCall({\n                interceptors: options.interceptors,\n                signal,\n                timeoutMs,\n                req: {\n                    stream: true,\n                    service,\n                    method,\n                    url: createMethodUrl(options.baseUrl, service, method),\n                    init: {\n                        method: \"POST\",\n                        credentials: (_a = options.credentials) !== null && _a !== void 0 ? _a : \"same-origin\",\n                        redirect: \"error\",\n                        mode: \"cors\",\n                    },\n                    header: requestHeader(useBinaryFormat, timeoutMs, header),\n                    message: input,\n                },\n                next: async (req) => {\n                    var _a;\n                    const fetch = (_a = options.fetch) !== null && _a !== void 0 ? _a : globalThis.fetch;\n                    const fRes = await fetch(req.url, Object.assign(Object.assign({}, req.init), { headers: req.header, signal: req.signal, body: await createRequestBody(req.message) }));\n                    const { foundStatus } = validateResponse(fRes.status, fRes.headers);\n                    if (!fRes.body) {\n                        throw \"missing response body\";\n                    }\n                    const trailer = new Headers();\n                    const res = Object.assign(Object.assign({}, req), { header: fRes.headers, trailer, message: parseResponseBody(fRes.body, foundStatus, trailer) });\n                    return res;\n                },\n            });\n        },\n    };\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBO,SAAS,iBAAiB;AAC7B,MAAI;AACA,QAAI,QAAQ;AAAA,EAChB,SACO,GAAG;AACN,UAAM,IAAI,MAAM,yKAAyK;AAAA,EAC7L;AACJ;;;ACVA,IAAI,UAAoC,SAAU,GAAG;AAAE,SAAO,gBAAgB,WAAW,KAAK,IAAI,GAAG,QAAQ,IAAI,QAAQ,CAAC;AAAG;AAC7H,IAAI,mBAAsD,SAAU,SAAS,YAAY,WAAW;AAChG,MAAI,CAAC,OAAO;AAAe,UAAM,IAAI,UAAU,sCAAsC;AACrF,MAAI,IAAI,UAAU,MAAM,SAAS,cAAc,CAAC,CAAC,GAAG,GAAG,IAAI,CAAC;AAC5D,SAAO,IAAI,CAAC,GAAG,KAAK,MAAM,GAAG,KAAK,OAAO,GAAG,KAAK,QAAQ,GAAG,EAAE,OAAO,aAAa,IAAI,WAAY;AAAE,WAAO;AAAA,EAAM,GAAG;AACpH,WAAS,KAAK,GAAG;AAAE,QAAI,EAAE,CAAC;AAAG,QAAE,CAAC,IAAI,SAAU,GAAG;AAAE,eAAO,IAAI,QAAQ,SAAU,GAAG,GAAG;AAAE,YAAE,KAAK,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC,IAAI,KAAK,OAAO,GAAG,CAAC;AAAA,QAAG,CAAC;AAAA,MAAG;AAAA,EAAG;AACzI,WAAS,OAAO,GAAG,GAAG;AAAE,QAAI;AAAE,WAAK,EAAE,CAAC,EAAE,CAAC,CAAC;AAAA,IAAG,SAAS,GAAG;AAAE,aAAO,EAAE,CAAC,EAAE,CAAC,GAAG,CAAC;AAAA,IAAG;AAAA,EAAE;AACjF,WAAS,KAAK,GAAG;AAAE,MAAE,iBAAiB,UAAU,QAAQ,QAAQ,EAAE,MAAM,CAAC,EAAE,KAAK,SAAS,MAAM,IAAI,OAAO,EAAE,CAAC,EAAE,CAAC,GAAG,CAAC;AAAA,EAAG;AACvH,WAAS,QAAQ,OAAO;AAAE,WAAO,QAAQ,KAAK;AAAA,EAAG;AACjD,WAAS,OAAO,OAAO;AAAE,WAAO,SAAS,KAAK;AAAA,EAAG;AACjD,WAAS,OAAO,GAAG,GAAG;AAAE,QAAI,EAAE,CAAC,GAAG,EAAE,MAAM,GAAG,EAAE;AAAQ,aAAO,EAAE,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC,CAAC;AAAA,EAAG;AACrF;AAWO,SAAS,uBAAuB,SAAS;AAC5C,MAAI;AACJ,iBAAe;AACf,QAAM,mBAAmB,KAAK,QAAQ,qBAAqB,QAAQ,OAAO,SAAS,KAAK;AACxF,SAAO;AAAA,IACH,MAAM,MAAM,SAAS,QAAQ,QAAQ,WAAW,QAAQ,SAAS;AAC7D,UAAIA;AACJ,YAAM,EAAE,WAAW,MAAM,IAAI,8BAA8B,QAAQ,iBAAiB,QAAQ,aAAa,QAAQ,aAAa;AAC9H,aAAO,MAAM,aAAa;AAAA,QACtB,cAAc,QAAQ;AAAA,QACtB;AAAA,QACA;AAAA,QACA,KAAK;AAAA,UACD,QAAQ;AAAA,UACR;AAAA,UACA;AAAA,UACA,KAAK,gBAAgB,QAAQ,SAAS,SAAS,MAAM;AAAA,UACrD,MAAM;AAAA,YACF,QAAQ;AAAA,YACR,cAAcA,MAAK,QAAQ,iBAAiB,QAAQA,QAAO,SAASA,MAAK;AAAA,YACzE,UAAU;AAAA,YACV,MAAM;AAAA,UACV;AAAA,UACA,QAAQ,cAAc,OAAO,MAAM,iBAAiB,WAAW,MAAM;AAAA,UACrE;AAAA,QACJ;AAAA,QACA,MAAM,OAAO,QAAQ;AACjB,cAAIA;AACJ,gBAAM,SAAS,QAAQ,eAAe,QAClC,OAAO,gBAAgB,kBAAkB;AAC7C,cAAI,OAAO;AACX,cAAI,QAAQ;AACR,kBAAM,iCAAiC,KAAK,UAAU,IAAI,OAAO,GAAG,eAAe;AAAA,UACvF,OACK;AACD,mBAAO,UAAU,IAAI,OAAO;AAAA,UAChC;AACA,gBAAM,SAASA,MAAK,QAAQ,WAAW,QAAQA,QAAO,SAASA,MAAK,WAAW;AAC/E,gBAAM,WAAW,MAAM,MAAM,IAAI,KAAK,OAAO,OAAO,OAAO,OAAO,CAAC,GAAG,IAAI,IAAI,GAAG,EAAE,SAAS,IAAI,QAAQ,QAAQ,IAAI,QAAQ,KAAK,CAAC,CAAC;AACnI,gBAAM,EAAE,cAAc,WAAW,IAAI,iBAAiB,OAAO,MAAM,SAAS,QAAQ,SAAS,OAAO;AACpG,cAAI,cAAc;AACd,kBAAM,cAAe,MAAM,SAAS,KAAK,GAAI,cAAc,GAAG,aAAa,SAAS,OAAO,CAAC,GAAG,UAAU;AAAA,UAC7G;AACA,gBAAM,CAAC,eAAe,cAAc,IAAI,aAAa,SAAS,OAAO;AACrE,iBAAO;AAAA,YACH,QAAQ;AAAA,YACR;AAAA,YACA;AAAA,YACA,QAAQ;AAAA,YACR,SAAS,kBACH,MAAM,IAAI,WAAW,MAAM,SAAS,YAAY,CAAC,CAAC,IAClD,OAAO,EAAE,SAAU,MAAM,SAAS,KAAK,GAAI,eAAe,QAAQ,WAAW,CAAC;AAAA,YACpF,SAAS;AAAA,UACb;AAAA,QACJ;AAAA,MACJ,CAAC;AAAA,IACL;AAAA,IACA,MAAM,OAAO,SAAS,QAAQ,QAAQ,WAAW,QAAQ,OAAO;AAC5D,UAAIA;AACJ,YAAM,EAAE,WAAW,MAAM,IAAI,8BAA8B,QAAQ,iBAAiB,QAAQ,aAAa,QAAQ,aAAa;AAC9H,eAAS,kBAAkB,MAAM,eAAe;AAC5C,eAAO,iBAAiB,MAAM,WAAW,UAAU,sBAAsB;AACrE,gBAAM,SAAS,6BAA6B,IAAI,EAAE,UAAU;AAC5D,cAAI,oBAAoB;AACxB,qBAAS;AACL,kBAAM,SAAS,MAAM,QAAQ,OAAO,KAAK,CAAC;AAC1C,gBAAI,OAAO,MAAM;AACb;AAAA,YACJ;AACA,kBAAM,EAAE,OAAO,KAAK,IAAI,OAAO;AAC/B,iBAAK,QAAQ,mBAAmB,eAAe;AAC3C,kCAAoB;AACpB,oBAAM,YAAY,kBAAkB,IAAI;AACxC,kBAAI,UAAU,OAAO;AACjB,sBAAM,UAAU;AAAA,cACpB;AACA,wBAAU,SAAS,QAAQ,CAAC,OAAO,QAAQ,cAAc,IAAI,KAAK,KAAK,CAAC;AACxE;AAAA,YACJ;AACA,kBAAM,MAAM,QAAQ,MAAM,IAAI,CAAC;AAAA,UACnC;AACA,cAAI,CAAC,mBAAmB;AACpB,kBAAM;AAAA,UACV;AAAA,QACJ,CAAC;AAAA,MACL;AACA,qBAAe,kBAAkBC,QAAO;AACpC,YAAI,OAAO,QAAQ,WAAW,iBAAiB;AAC3C,gBAAM;AAAA,QACV;AACA,cAAM,IAAI,MAAMA,OAAM,OAAO,aAAa,EAAE,EAAE,KAAK;AACnD,YAAI,EAAE,QAAQ,MAAM;AAChB,gBAAM;AAAA,QACV;AACA,eAAO,eAAe,GAAG,UAAU,EAAE,KAAK,CAAC;AAAA,MAC/C;AACA,aAAO,MAAM,iBAAiB;AAAA,QAC1B,cAAc,QAAQ;AAAA,QACtB;AAAA,QACA;AAAA,QACA,KAAK;AAAA,UACD,QAAQ;AAAA,UACR;AAAA,UACA;AAAA,UACA,KAAK,gBAAgB,QAAQ,SAAS,SAAS,MAAM;AAAA,UACrD,MAAM;AAAA,YACF,QAAQ;AAAA,YACR,cAAcD,MAAK,QAAQ,iBAAiB,QAAQA,QAAO,SAASA,MAAK;AAAA,YACzE,UAAU;AAAA,YACV,MAAM;AAAA,UACV;AAAA,UACA,QAAQ,cAAc,OAAO,MAAM,iBAAiB,WAAW,MAAM;AAAA,UACrE,SAAS;AAAA,QACb;AAAA,QACA,MAAM,OAAO,QAAQ;AACjB,cAAIA;AACJ,gBAAM,SAASA,MAAK,QAAQ,WAAW,QAAQA,QAAO,SAASA,MAAK,WAAW;AAC/E,gBAAM,OAAO,MAAM,MAAM,IAAI,KAAK,OAAO,OAAO,OAAO,OAAO,CAAC,GAAG,IAAI,IAAI,GAAG,EAAE,SAAS,IAAI,QAAQ,QAAQ,IAAI,QAAQ,MAAM,MAAM,kBAAkB,IAAI,OAAO,EAAE,CAAC,CAAC;AACrK,2BAAiB,OAAO,MAAM,KAAK,QAAQ,KAAK,OAAO;AACvD,cAAI,KAAK,SAAS,MAAM;AACpB,kBAAM;AAAA,UACV;AACA,gBAAM,UAAU,IAAI,QAAQ;AAC5B,gBAAM,MAAM,OAAO,OAAO,OAAO,OAAO,CAAC,GAAG,GAAG,GAAG,EAAE,QAAQ,KAAK,SAAS,SAAS,SAAS,kBAAkB,KAAK,MAAM,OAAO,EAAE,CAAC;AACnI,iBAAO;AAAA,QACX;AAAA,MACJ,CAAC;AAAA,IACL;AAAA,EACJ;AACJ;;;AChJO,SAAS,gBAAgB,SAAS;AACrC,QAAM,MAAM,iBAAiB,OAAO;AACpC,MAAI,KAAK;AACL,UAAM;AAAA,EACV;AACJ;;;ACLO,SAASE,eAAc,iBAAiB,WAAW,qBAAqB;AAC3E,QAAM,SAAS,IAAI,QAAQ,wBAAwB,QAAQ,wBAAwB,SAAS,sBAAsB,CAAC,CAAC;AAGpH,SAAO,IAAI,mBAAmB,kBAAkB,mBAAmB,eAAe;AAClF,SAAO,IAAI,gBAAgB,GAAG;AAI9B,SAAO,IAAI,kBAAkB,mBAAmB;AAChD,MAAI,cAAc,QAAW;AACzB,WAAO,IAAI,eAAe,GAAG,SAAS,GAAG;AAAA,EAC7C;AACA,SAAO;AACX;;;ACdO,SAASC,oBAAmB,YAAY;AAC3C,UAAQ,YAAY;AAAA,IAChB,KAAK;AACD,aAAO,KAAK;AAAA,IAChB,KAAK;AACD,aAAO,KAAK;AAAA,IAChB,KAAK;AACD,aAAO,KAAK;AAAA,IAChB,KAAK;AACD,aAAO,KAAK;AAAA,IAChB,KAAK;AACD,aAAO,KAAK;AAAA,IAChB,KAAK;AACD,aAAO,KAAK;AAAA,IAChB,KAAK;AACD,aAAO,KAAK;AAAA,IAChB,KAAK;AACD,aAAO,KAAK;AAAA,IAChB;AAEI,aAAO,KAAK;AAAA,EACpB;AACJ;;;ACZO,SAASC,kBAAiB,QAAQ,SAAS;AAC9C,MAAI;AAGJ,MAAI,UAAU,OAAO,SAAS,KAAK;AAC/B,UAAM,MAAM,iBAAiB,OAAO;AACpC,QAAI,KAAK;AACL,YAAM;AAAA,IACV;AACA,WAAO,EAAE,aAAa,QAAQ,IAAI,gBAAgB,EAAE;AAAA,EACxD;AACA,QAAM,IAAI,aAAa,oBAAoB,KAAK,QAAQ,IAAI,iBAAiB,OAAO,QAAQ,OAAO,SAAS,KAAK,QAAQ,MAAM,EAAE,GAAGC,oBAAmB,MAAM,GAAG,OAAO;AAC3K;;;AC7BA,IAAIC,WAAoC,SAAU,GAAG;AAAE,SAAO,gBAAgBA,YAAW,KAAK,IAAI,GAAG,QAAQ,IAAIA,SAAQ,CAAC;AAAG;AAC7H,IAAIC,oBAAsD,SAAU,SAAS,YAAY,WAAW;AAChG,MAAI,CAAC,OAAO;AAAe,UAAM,IAAI,UAAU,sCAAsC;AACrF,MAAI,IAAI,UAAU,MAAM,SAAS,cAAc,CAAC,CAAC,GAAG,GAAG,IAAI,CAAC;AAC5D,SAAO,IAAI,CAAC,GAAG,KAAK,MAAM,GAAG,KAAK,OAAO,GAAG,KAAK,QAAQ,GAAG,EAAE,OAAO,aAAa,IAAI,WAAY;AAAE,WAAO;AAAA,EAAM,GAAG;AACpH,WAAS,KAAK,GAAG;AAAE,QAAI,EAAE,CAAC;AAAG,QAAE,CAAC,IAAI,SAAU,GAAG;AAAE,eAAO,IAAI,QAAQ,SAAU,GAAG,GAAG;AAAE,YAAE,KAAK,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC,IAAI,KAAK,OAAO,GAAG,CAAC;AAAA,QAAG,CAAC;AAAA,MAAG;AAAA,EAAG;AACzI,WAAS,OAAO,GAAG,GAAG;AAAE,QAAI;AAAE,WAAK,EAAE,CAAC,EAAE,CAAC,CAAC;AAAA,IAAG,SAAS,GAAG;AAAE,aAAO,EAAE,CAAC,EAAE,CAAC,GAAG,CAAC;AAAA,IAAG;AAAA,EAAE;AACjF,WAAS,KAAK,GAAG;AAAE,MAAE,iBAAiBD,WAAU,QAAQ,QAAQ,EAAE,MAAM,CAAC,EAAE,KAAK,SAAS,MAAM,IAAI,OAAO,EAAE,CAAC,EAAE,CAAC,GAAG,CAAC;AAAA,EAAG;AACvH,WAAS,QAAQ,OAAO;AAAE,WAAO,QAAQ,KAAK;AAAA,EAAG;AACjD,WAAS,OAAO,OAAO;AAAE,WAAO,SAAS,KAAK;AAAA,EAAG;AACjD,WAAS,OAAO,GAAG,GAAG;AAAE,QAAI,EAAE,CAAC,GAAG,EAAE,MAAM,GAAG,EAAE;AAAQ,aAAO,EAAE,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC,CAAC;AAAA,EAAG;AACrF;AAeO,SAAS,uBAAuB,SAAS;AAC5C,MAAI;AACJ,iBAAe;AACf,QAAM,mBAAmB,KAAK,QAAQ,qBAAqB,QAAQ,OAAO,SAAS,KAAK;AACxF,SAAO;AAAA,IACH,MAAM,MAAM,SAAS,QAAQ,QAAQ,WAAW,QAAQ,SAAS;AAC7D,UAAIE;AACJ,YAAM,EAAE,WAAW,MAAM,IAAI,8BAA8B,QAAQ,iBAAiB,QAAQ,aAAa,QAAQ,aAAa;AAC9H,aAAO,MAAM,aAAa;AAAA,QACtB,cAAc,QAAQ;AAAA,QACtB;AAAA,QACA;AAAA,QACA,KAAK;AAAA,UACD,QAAQ;AAAA,UACR;AAAA,UACA;AAAA,UACA,KAAK,gBAAgB,QAAQ,SAAS,SAAS,MAAM;AAAA,UACrD,MAAM;AAAA,YACF,QAAQ;AAAA,YACR,cAAcA,MAAK,QAAQ,iBAAiB,QAAQA,QAAO,SAASA,MAAK;AAAA,YACzE,UAAU;AAAA,YACV,MAAM;AAAA,UACV;AAAA,UACA,QAAQC,eAAc,iBAAiB,WAAW,MAAM;AAAA,UACxD;AAAA,QACJ;AAAA,QACA,MAAM,OAAO,QAAQ;AACjB,cAAID;AACJ,gBAAM,SAASA,MAAK,QAAQ,WAAW,QAAQA,QAAO,SAASA,MAAK,WAAW;AAC/E,gBAAM,WAAW,MAAM,MAAM,IAAI,KAAK,OAAO,OAAO,OAAO,OAAO,CAAC,GAAG,IAAI,IAAI,GAAG,EAAE,SAAS,IAAI,QAAQ,QAAQ,IAAI,QAAQ,MAAM,eAAe,GAAG,UAAU,IAAI,OAAO,CAAC,EAAE,CAAC,CAAC;AAC9K,UAAAE,kBAAiB,SAAS,QAAQ,SAAS,OAAO;AAClD,cAAI,CAAC,SAAS,MAAM;AAChB,kBAAM;AAAA,UACV;AACA,gBAAM,SAAS,6BAA6B,SAAS,IAAI,EAAE,UAAU;AACrE,cAAI;AACJ,cAAIC;AACJ,qBAAS;AACL,kBAAM,IAAI,MAAM,OAAO,KAAK;AAC5B,gBAAI,EAAE,MAAM;AACR;AAAA,YACJ;AACA,kBAAM,EAAE,OAAO,KAAK,IAAI,EAAE;AAC1B,gBAAI,UAAU,aAAa;AACvB,kBAAI,YAAY,QAAW;AACvB,sBAAM;AAAA,cACV;AAIA,wBAAU,aAAa,IAAI;AAC3B;AAAA,YACJ;AACA,gBAAIA,aAAY,QAAW;AACvB,oBAAM;AAAA,YACV;AACA,YAAAA,WAAU,MAAM,IAAI;AAAA,UACxB;AACA,cAAI,YAAY,QAAW;AACvB,kBAAM;AAAA,UACV;AACA,0BAAgB,OAAO;AACvB,cAAIA,aAAY,QAAW;AACvB,kBAAM;AAAA,UACV;AACA,iBAAO;AAAA,YACH,QAAQ;AAAA,YACR,QAAQ,SAAS;AAAA,YACjB,SAAAA;AAAA,YACA;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ,CAAC;AAAA,IACL;AAAA,IACA,MAAM,OAAO,SAAS,QAAQ,QAAQ,WAAW,QAAQ,OAAO;AAC5D,UAAIH;AACJ,YAAM,EAAE,WAAW,MAAM,IAAI,8BAA8B,QAAQ,iBAAiB,QAAQ,aAAa,QAAQ,aAAa;AAC9H,eAAS,kBAAkB,MAAM,aAAa,eAAe;AACzD,eAAOD,kBAAiB,MAAM,WAAW,UAAU,sBAAsB;AACrE,gBAAM,SAAS,6BAA6B,IAAI,EAAE,UAAU;AAC5D,cAAI,aAAa;AASb,gBAAI,EAAE,MAAMD,SAAQ,OAAO,KAAK,CAAC,GAAG,MAAM;AACtC,oBAAM;AAAA,YACV;AACA,mBAAO,MAAMA,SAAQ,MAAM;AAAA,UAC/B;AACA,cAAI,kBAAkB;AACtB,qBAAS;AACL,kBAAM,SAAS,MAAMA,SAAQ,OAAO,KAAK,CAAC;AAC1C,gBAAI,OAAO,MAAM;AACb;AAAA,YACJ;AACA,kBAAM,EAAE,OAAO,KAAK,IAAI,OAAO;AAC/B,iBAAK,QAAQ,iBAAiB,aAAa;AACvC,kBAAI,iBAAiB;AACjB,sBAAM;AAAA,cACV;AACA,gCAAkB;AAClB,oBAAM,UAAU,aAAa,IAAI;AACjC,8BAAgB,OAAO;AACvB,sBAAQ,QAAQ,CAAC,OAAO,QAAQ,cAAc,IAAI,KAAK,KAAK,CAAC;AAC7D;AAAA,YACJ;AACA,gBAAI,iBAAiB;AACjB,oBAAM;AAAA,YACV;AACA,kBAAM,MAAMA,SAAQ,MAAM,IAAI,CAAC;AAC/B;AAAA,UACJ;AACA,cAAI,CAAC,iBAAiB;AAClB,kBAAM;AAAA,UACV;AAAA,QACJ,CAAC;AAAA,MACL;AACA,qBAAe,kBAAkBM,QAAO;AACpC,YAAI,OAAO,QAAQ,WAAW,iBAAiB;AAC3C,gBAAM;AAAA,QACV;AACA,cAAM,IAAI,MAAMA,OAAM,OAAO,aAAa,EAAE,EAAE,KAAK;AACnD,YAAI,EAAE,QAAQ,MAAM;AAChB,gBAAM;AAAA,QACV;AACA,eAAO,eAAe,GAAG,UAAU,EAAE,KAAK,CAAC;AAAA,MAC/C;AACA,aAAO,iBAAiB;AAAA,QACpB,cAAc,QAAQ;AAAA,QACtB;AAAA,QACA;AAAA,QACA,KAAK;AAAA,UACD,QAAQ;AAAA,UACR;AAAA,UACA;AAAA,UACA,KAAK,gBAAgB,QAAQ,SAAS,SAAS,MAAM;AAAA,UACrD,MAAM;AAAA,YACF,QAAQ;AAAA,YACR,cAAcJ,MAAK,QAAQ,iBAAiB,QAAQA,QAAO,SAASA,MAAK;AAAA,YACzE,UAAU;AAAA,YACV,MAAM;AAAA,UACV;AAAA,UACA,QAAQC,eAAc,iBAAiB,WAAW,MAAM;AAAA,UACxD,SAAS;AAAA,QACb;AAAA,QACA,MAAM,OAAO,QAAQ;AACjB,cAAID;AACJ,gBAAM,SAASA,MAAK,QAAQ,WAAW,QAAQA,QAAO,SAASA,MAAK,WAAW;AAC/E,gBAAM,OAAO,MAAM,MAAM,IAAI,KAAK,OAAO,OAAO,OAAO,OAAO,CAAC,GAAG,IAAI,IAAI,GAAG,EAAE,SAAS,IAAI,QAAQ,QAAQ,IAAI,QAAQ,MAAM,MAAM,kBAAkB,IAAI,OAAO,EAAE,CAAC,CAAC;AACrK,gBAAM,EAAE,YAAY,IAAIE,kBAAiB,KAAK,QAAQ,KAAK,OAAO;AAClE,cAAI,CAAC,KAAK,MAAM;AACZ,kBAAM;AAAA,UACV;AACA,gBAAM,UAAU,IAAI,QAAQ;AAC5B,gBAAM,MAAM,OAAO,OAAO,OAAO,OAAO,CAAC,GAAG,GAAG,GAAG,EAAE,QAAQ,KAAK,SAAS,SAAS,SAAS,kBAAkB,KAAK,MAAM,aAAa,OAAO,EAAE,CAAC;AAChJ,iBAAO;AAAA,QACX;AAAA,MACJ,CAAC;AAAA,IACL;AAAA,EACJ;AACJ;",
  "names": ["_a", "input", "requestHeader", "codeFromHttpStatus", "validateResponse", "codeFromHttpStatus", "__await", "__asyncGenerator", "_a", "requestHeader", "validateResponse", "message", "input"]
}
