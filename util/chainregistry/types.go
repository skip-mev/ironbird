// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package chainregistry

import "encoding/json"
import "fmt"
import "reflect"
import "regexp"

type Binaries struct {
	// DarwinAmd64 corresponds to the JSON schema field "darwin/amd64".
	DarwinAmd64 *string `json:"darwin/amd64,omitempty" yaml:"darwin/amd64,omitempty" mapstructure:"darwin/amd64,omitempty"`

	// DarwinArm64 corresponds to the JSON schema field "darwin/arm64".
	DarwinArm64 *string `json:"darwin/arm64,omitempty" yaml:"darwin/arm64,omitempty" mapstructure:"darwin/arm64,omitempty"`

	// LinuxAmd64 corresponds to the JSON schema field "linux/amd64".
	LinuxAmd64 *string `json:"linux/amd64,omitempty" yaml:"linux/amd64,omitempty" mapstructure:"linux/amd64,omitempty"`

	// LinuxArm64 corresponds to the JSON schema field "linux/arm64".
	LinuxArm64 *string `json:"linux/arm64,omitempty" yaml:"linux/arm64,omitempty" mapstructure:"linux/arm64,omitempty"`

	// WindowsAmd64 corresponds to the JSON schema field "windows/amd64".
	WindowsAmd64 *string `json:"windows/amd64,omitempty" yaml:"windows/amd64,omitempty" mapstructure:"windows/amd64,omitempty"`

	// WindowsArm64 corresponds to the JSON schema field "windows/arm64".
	WindowsArm64 *string `json:"windows/arm64,omitempty" yaml:"windows/arm64,omitempty" mapstructure:"windows/arm64,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Binaries) UnmarshalJSON(value []byte) error {
	type Plain Binaries
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.DarwinAmd64 != nil && len(*plain.DarwinAmd64) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "darwin/amd64", 1)
	}
	if plain.DarwinArm64 != nil && len(*plain.DarwinArm64) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "darwin/arm64", 1)
	}
	if plain.LinuxAmd64 != nil && len(*plain.LinuxAmd64) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "linux/amd64", 1)
	}
	if plain.LinuxArm64 != nil && len(*plain.LinuxArm64) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "linux/arm64", 1)
	}
	if plain.WindowsAmd64 != nil && len(*plain.WindowsAmd64) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "windows/amd64", 1)
	}
	if plain.WindowsArm64 != nil && len(*plain.WindowsArm64) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "windows/arm64", 1)
	}
	*j = Binaries(plain)
	return nil
}

// Chain.json is a metadata file that contains information about a blockchain.
type ChainSchemaJson interface{}

type ChainSchemaJsonApis struct {
	// EvmHttpJsonrpc corresponds to the JSON schema field "evm-http-jsonrpc".
	EvmHttpJsonrpc []Endpoint `json:"evm-http-jsonrpc,omitempty" yaml:"evm-http-jsonrpc,omitempty" mapstructure:"evm-http-jsonrpc,omitempty"`

	// Grpc corresponds to the JSON schema field "grpc".
	Grpc []Endpoint `json:"grpc,omitempty" yaml:"grpc,omitempty" mapstructure:"grpc,omitempty"`

	// GrpcWeb corresponds to the JSON schema field "grpc-web".
	GrpcWeb []Endpoint `json:"grpc-web,omitempty" yaml:"grpc-web,omitempty" mapstructure:"grpc-web,omitempty"`

	// Rest corresponds to the JSON schema field "rest".
	Rest []Endpoint `json:"rest,omitempty" yaml:"rest,omitempty" mapstructure:"rest,omitempty"`

	// Rpc corresponds to the JSON schema field "rpc".
	Rpc []Endpoint `json:"rpc,omitempty" yaml:"rpc,omitempty" mapstructure:"rpc,omitempty"`

	// Wss corresponds to the JSON schema field "wss".
	Wss []Endpoint `json:"wss,omitempty" yaml:"wss,omitempty" mapstructure:"wss,omitempty"`
}

// Used to override the bech32_prefix for specific uses.
type ChainSchemaJsonBech32Config struct {
	// e.g., 'cosmos'
	Bech32PrefixAccAddr *string `json:"bech32PrefixAccAddr,omitempty" yaml:"bech32PrefixAccAddr,omitempty" mapstructure:"bech32PrefixAccAddr,omitempty"`

	// e.g., 'cosmospub'
	Bech32PrefixAccPub *string `json:"bech32PrefixAccPub,omitempty" yaml:"bech32PrefixAccPub,omitempty" mapstructure:"bech32PrefixAccPub,omitempty"`

	// e.g., 'cosmosvalcons'
	Bech32PrefixConsAddr *string `json:"bech32PrefixConsAddr,omitempty" yaml:"bech32PrefixConsAddr,omitempty" mapstructure:"bech32PrefixConsAddr,omitempty"`

	// e.g., 'cosmosvalconspub'
	Bech32PrefixConsPub *string `json:"bech32PrefixConsPub,omitempty" yaml:"bech32PrefixConsPub,omitempty" mapstructure:"bech32PrefixConsPub,omitempty"`

	// e.g., 'cosmosvaloper'
	Bech32PrefixValAddr *string `json:"bech32PrefixValAddr,omitempty" yaml:"bech32PrefixValAddr,omitempty" mapstructure:"bech32PrefixValAddr,omitempty"`

	// e.g., 'cosmosvaloperpub'
	Bech32PrefixValPub *string `json:"bech32PrefixValPub,omitempty" yaml:"bech32PrefixValPub,omitempty" mapstructure:"bech32PrefixValPub,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ChainSchemaJsonBech32Config) UnmarshalJSON(value []byte) error {
	type Plain ChainSchemaJsonBech32Config
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Bech32PrefixAccAddr != nil && len(*plain.Bech32PrefixAccAddr) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "bech32PrefixAccAddr", 1)
	}
	if plain.Bech32PrefixAccPub != nil && len(*plain.Bech32PrefixAccPub) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "bech32PrefixAccPub", 1)
	}
	if plain.Bech32PrefixConsAddr != nil && len(*plain.Bech32PrefixConsAddr) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "bech32PrefixConsAddr", 1)
	}
	if plain.Bech32PrefixConsPub != nil && len(*plain.Bech32PrefixConsPub) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "bech32PrefixConsPub", 1)
	}
	if plain.Bech32PrefixValAddr != nil && len(*plain.Bech32PrefixValAddr) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "bech32PrefixValAddr", 1)
	}
	if plain.Bech32PrefixValPub != nil && len(*plain.Bech32PrefixValPub) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "bech32PrefixValPub", 1)
	}
	*j = ChainSchemaJsonBech32Config(plain)
	return nil
}

type ChainSchemaJsonChainType string

const ChainSchemaJsonChainTypeAlgorand ChainSchemaJsonChainType = "algorand"
const ChainSchemaJsonChainTypeArweave ChainSchemaJsonChainType = "arweave"
const ChainSchemaJsonChainTypeBip122 ChainSchemaJsonChainType = "bip122"
const ChainSchemaJsonChainTypeCosmos ChainSchemaJsonChainType = "cosmos"
const ChainSchemaJsonChainTypeEip155 ChainSchemaJsonChainType = "eip155"
const ChainSchemaJsonChainTypeErgo ChainSchemaJsonChainType = "ergo"
const ChainSchemaJsonChainTypeFil ChainSchemaJsonChainType = "fil"
const ChainSchemaJsonChainTypeHedera ChainSchemaJsonChainType = "hedera"
const ChainSchemaJsonChainTypeMonero ChainSchemaJsonChainType = "monero"
const ChainSchemaJsonChainTypePolkadot ChainSchemaJsonChainType = "polkadot"
const ChainSchemaJsonChainTypeReef ChainSchemaJsonChainType = "reef"
const ChainSchemaJsonChainTypeSolana ChainSchemaJsonChainType = "solana"
const ChainSchemaJsonChainTypeStacks ChainSchemaJsonChainType = "stacks"
const ChainSchemaJsonChainTypeStarknet ChainSchemaJsonChainType = "starknet"
const ChainSchemaJsonChainTypeStellar ChainSchemaJsonChainType = "stellar"
const ChainSchemaJsonChainTypeTezos ChainSchemaJsonChainType = "tezos"
const ChainSchemaJsonChainTypeUnknown ChainSchemaJsonChainType = "unknown"
const ChainSchemaJsonChainTypeVechain ChainSchemaJsonChainType = "vechain"
const ChainSchemaJsonChainTypeWaves ChainSchemaJsonChainType = "waves"
const ChainSchemaJsonChainTypeXrpl ChainSchemaJsonChainType = "xrpl"

var enumValues_ChainSchemaJsonChainType = []interface{}{
	"cosmos",
	"eip155",
	"bip122",
	"polkadot",
	"solana",
	"algorand",
	"arweave",
	"ergo",
	"fil",
	"hedera",
	"monero",
	"reef",
	"stacks",
	"starknet",
	"stellar",
	"tezos",
	"vechain",
	"waves",
	"xrpl",
	"unknown",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ChainSchemaJsonChainType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ChainSchemaJsonChainType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ChainSchemaJsonChainType, v)
	}
	*j = ChainSchemaJsonChainType(v)
	return nil
}

type ChainSchemaJsonCodebase struct {
	// Binaries corresponds to the JSON schema field "binaries".
	Binaries *Binaries `json:"binaries,omitempty" yaml:"binaries,omitempty" mapstructure:"binaries,omitempty"`

	// CompatibleVersions corresponds to the JSON schema field "compatible_versions".
	CompatibleVersions []string `json:"compatible_versions,omitempty" yaml:"compatible_versions,omitempty" mapstructure:"compatible_versions,omitempty"`

	// Consensus corresponds to the JSON schema field "consensus".
	Consensus *Consensus `json:"consensus,omitempty" yaml:"consensus,omitempty" mapstructure:"consensus,omitempty"`

	// Cosmwasm corresponds to the JSON schema field "cosmwasm".
	Cosmwasm *Cosmwasm `json:"cosmwasm,omitempty" yaml:"cosmwasm,omitempty" mapstructure:"cosmwasm,omitempty"`

	// Genesis corresponds to the JSON schema field "genesis".
	Genesis *ChainSchemaJsonCodebaseGenesis `json:"genesis,omitempty" yaml:"genesis,omitempty" mapstructure:"genesis,omitempty"`

	// GitRepo corresponds to the JSON schema field "git_repo".
	GitRepo *string `json:"git_repo,omitempty" yaml:"git_repo,omitempty" mapstructure:"git_repo,omitempty"`

	// Ibc corresponds to the JSON schema field "ibc".
	Ibc *Ibc `json:"ibc,omitempty" yaml:"ibc,omitempty" mapstructure:"ibc,omitempty"`

	// Language corresponds to the JSON schema field "language".
	Language *Language `json:"language,omitempty" yaml:"language,omitempty" mapstructure:"language,omitempty"`

	// RecommendedVersion corresponds to the JSON schema field "recommended_version".
	RecommendedVersion *string `json:"recommended_version,omitempty" yaml:"recommended_version,omitempty" mapstructure:"recommended_version,omitempty"`

	// Sdk corresponds to the JSON schema field "sdk".
	Sdk *Sdk `json:"sdk,omitempty" yaml:"sdk,omitempty" mapstructure:"sdk,omitempty"`

	// Tag corresponds to the JSON schema field "tag".
	Tag *Tag `json:"tag,omitempty" yaml:"tag,omitempty" mapstructure:"tag,omitempty"`
}

type ChainSchemaJsonCodebaseGenesis struct {
	// GenesisUrl corresponds to the JSON schema field "genesis_url".
	GenesisUrl string `json:"genesis_url" yaml:"genesis_url" mapstructure:"genesis_url"`

	// IcsCcvUrl corresponds to the JSON schema field "ics_ccv_url".
	IcsCcvUrl *string `json:"ics_ccv_url,omitempty" yaml:"ics_ccv_url,omitempty" mapstructure:"ics_ccv_url,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ChainSchemaJsonCodebaseGenesis) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["genesis_url"]; raw != nil && !ok {
		return fmt.Errorf("field genesis_url in ChainSchemaJsonCodebaseGenesis: required")
	}
	type Plain ChainSchemaJsonCodebaseGenesis
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.GenesisUrl) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "genesis_url", 1)
	}
	if plain.IcsCcvUrl != nil && len(*plain.IcsCcvUrl) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "ics_ccv_url", 1)
	}
	if plain.Name != nil && len(*plain.Name) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "name", 1)
	}
	*j = ChainSchemaJsonCodebaseGenesis(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ChainSchemaJsonCodebase) UnmarshalJSON(value []byte) error {
	type Plain ChainSchemaJsonCodebase
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.GitRepo != nil && len(*plain.GitRepo) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "git_repo", 1)
	}
	if plain.RecommendedVersion != nil && len(*plain.RecommendedVersion) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "recommended_version", 1)
	}
	*j = ChainSchemaJsonCodebase(plain)
	return nil
}

type ChainSchemaJsonExtraCodecsElem string

const ChainSchemaJsonExtraCodecsElemEthermint ChainSchemaJsonExtraCodecsElem = "ethermint"
const ChainSchemaJsonExtraCodecsElemInjective ChainSchemaJsonExtraCodecsElem = "injective"

var enumValues_ChainSchemaJsonExtraCodecsElem = []interface{}{
	"ethermint",
	"injective",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ChainSchemaJsonExtraCodecsElem) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ChainSchemaJsonExtraCodecsElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ChainSchemaJsonExtraCodecsElem, v)
	}
	*j = ChainSchemaJsonExtraCodecsElem(v)
	return nil
}

type ChainSchemaJsonFees struct {
	// FeeTokens corresponds to the JSON schema field "fee_tokens".
	FeeTokens []FeeToken `json:"fee_tokens" yaml:"fee_tokens" mapstructure:"fee_tokens"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ChainSchemaJsonFees) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["fee_tokens"]; raw != nil && !ok {
		return fmt.Errorf("field fee_tokens in ChainSchemaJsonFees: required")
	}
	type Plain ChainSchemaJsonFees
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ChainSchemaJsonFees(plain)
	return nil
}

type ChainSchemaJsonKeyAlgosElem string

const ChainSchemaJsonKeyAlgosElemBn254 ChainSchemaJsonKeyAlgosElem = "bn254"
const ChainSchemaJsonKeyAlgosElemEd25519 ChainSchemaJsonKeyAlgosElem = "ed25519"
const ChainSchemaJsonKeyAlgosElemEthsecp256K1 ChainSchemaJsonKeyAlgosElem = "ethsecp256k1"
const ChainSchemaJsonKeyAlgosElemSecp256K1 ChainSchemaJsonKeyAlgosElem = "secp256k1"
const ChainSchemaJsonKeyAlgosElemSr25519 ChainSchemaJsonKeyAlgosElem = "sr25519"

var enumValues_ChainSchemaJsonKeyAlgosElem = []interface{}{
	"secp256k1",
	"ethsecp256k1",
	"ed25519",
	"sr25519",
	"bn254",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ChainSchemaJsonKeyAlgosElem) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ChainSchemaJsonKeyAlgosElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ChainSchemaJsonKeyAlgosElem, v)
	}
	*j = ChainSchemaJsonKeyAlgosElem(v)
	return nil
}

type ChainSchemaJsonLogoURIs struct {
	// Png corresponds to the JSON schema field "png".
	Png *string `json:"png,omitempty" yaml:"png,omitempty" mapstructure:"png,omitempty"`

	// Svg corresponds to the JSON schema field "svg".
	Svg *string `json:"svg,omitempty" yaml:"svg,omitempty" mapstructure:"svg,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ChainSchemaJsonLogoURIs) UnmarshalJSON(value []byte) error {
	type Plain ChainSchemaJsonLogoURIs
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Png != nil {
		if matched, _ := regexp.MatchString(`^https://raw\.githubusercontent\.com/cosmos/chain-registry/master/(|testnets/|_non-cosmos/)[a-z0-9]+/images/.+\.png$`, string(*plain.Png)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "Png", `^https://raw\.githubusercontent\.com/cosmos/chain-registry/master/(|testnets/|_non-cosmos/)[a-z0-9]+/images/.+\.png$`)
		}
	}
	if plain.Png != nil && len(*plain.Png) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "png", 1)
	}
	if plain.Svg != nil {
		if matched, _ := regexp.MatchString(`^https://raw\.githubusercontent\.com/cosmos/chain-registry/master/(|testnets/|_non-cosmos/)[a-z0-9]+/images/.+\.svg$`, string(*plain.Svg)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "Svg", `^https://raw\.githubusercontent\.com/cosmos/chain-registry/master/(|testnets/|_non-cosmos/)[a-z0-9]+/images/.+\.svg$`)
		}
	}
	if plain.Svg != nil && len(*plain.Svg) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "svg", 1)
	}
	*j = ChainSchemaJsonLogoURIs(plain)
	return nil
}

type ChainSchemaJsonNetworkType string

const ChainSchemaJsonNetworkTypeDevnet ChainSchemaJsonNetworkType = "devnet"
const ChainSchemaJsonNetworkTypeMainnet ChainSchemaJsonNetworkType = "mainnet"
const ChainSchemaJsonNetworkTypeTestnet ChainSchemaJsonNetworkType = "testnet"

var enumValues_ChainSchemaJsonNetworkType = []interface{}{
	"mainnet",
	"testnet",
	"devnet",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ChainSchemaJsonNetworkType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ChainSchemaJsonNetworkType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ChainSchemaJsonNetworkType, v)
	}
	*j = ChainSchemaJsonNetworkType(v)
	return nil
}

type ChainSchemaJsonPeers struct {
	// PersistentPeers corresponds to the JSON schema field "persistent_peers".
	PersistentPeers []Peer `json:"persistent_peers,omitempty" yaml:"persistent_peers,omitempty" mapstructure:"persistent_peers,omitempty"`

	// Seeds corresponds to the JSON schema field "seeds".
	Seeds []Peer `json:"seeds,omitempty" yaml:"seeds,omitempty" mapstructure:"seeds,omitempty"`
}

type ChainSchemaJsonStaking struct {
	// LockDuration corresponds to the JSON schema field "lock_duration".
	LockDuration *ChainSchemaJsonStakingLockDuration `json:"lock_duration,omitempty" yaml:"lock_duration,omitempty" mapstructure:"lock_duration,omitempty"`

	// StakingTokens corresponds to the JSON schema field "staking_tokens".
	StakingTokens []StakingToken `json:"staking_tokens" yaml:"staking_tokens" mapstructure:"staking_tokens"`
}

type ChainSchemaJsonStakingLockDuration struct {
	// The number of blocks for which the staked tokens are locked.
	Blocks *float64 `json:"blocks,omitempty" yaml:"blocks,omitempty" mapstructure:"blocks,omitempty"`

	// The approximate time for which the staked tokens are locked.
	Time *string `json:"time,omitempty" yaml:"time,omitempty" mapstructure:"time,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ChainSchemaJsonStakingLockDuration) UnmarshalJSON(value []byte) error {
	type Plain ChainSchemaJsonStakingLockDuration
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Time != nil && len(*plain.Time) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "time", 1)
	}
	*j = ChainSchemaJsonStakingLockDuration(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ChainSchemaJsonStaking) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["staking_tokens"]; raw != nil && !ok {
		return fmt.Errorf("field staking_tokens in ChainSchemaJsonStaking: required")
	}
	type Plain ChainSchemaJsonStaking
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ChainSchemaJsonStaking(plain)
	return nil
}

type ChainSchemaJsonStatus string

const ChainSchemaJsonStatusKilled ChainSchemaJsonStatus = "killed"
const ChainSchemaJsonStatusLive ChainSchemaJsonStatus = "live"
const ChainSchemaJsonStatusUpcoming ChainSchemaJsonStatus = "upcoming"

var enumValues_ChainSchemaJsonStatus = []interface{}{
	"live",
	"upcoming",
	"killed",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ChainSchemaJsonStatus) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ChainSchemaJsonStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ChainSchemaJsonStatus, v)
	}
	*j = ChainSchemaJsonStatus(v)
	return nil
}

type Consensus struct {
	// Repo corresponds to the JSON schema field "repo".
	Repo *Repo `json:"repo,omitempty" yaml:"repo,omitempty" mapstructure:"repo,omitempty"`

	// Tag corresponds to the JSON schema field "tag".
	Tag *Tag `json:"tag,omitempty" yaml:"tag,omitempty" mapstructure:"tag,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type ConsensusType `json:"type" yaml:"type" mapstructure:"type"`

	// Version corresponds to the JSON schema field "version".
	Version *Version `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`
}

type ConsensusType string

const ConsensusTypeCometbft ConsensusType = "cometbft"
const ConsensusTypeSeiTendermint ConsensusType = "sei-tendermint"
const ConsensusTypeTendermint ConsensusType = "tendermint"

var enumValues_ConsensusType = []interface{}{
	"tendermint",
	"cometbft",
	"sei-tendermint",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConsensusType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ConsensusType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ConsensusType, v)
	}
	*j = ConsensusType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Consensus) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in Consensus: required")
	}
	type Plain Consensus
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Consensus(plain)
	return nil
}

type Cosmwasm struct {
	// Enabled corresponds to the JSON schema field "enabled".
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Relative path to the cosmwasm directory. ex. $HOME/.juno/data/wasm
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// Repo corresponds to the JSON schema field "repo".
	Repo *Repo `json:"repo,omitempty" yaml:"repo,omitempty" mapstructure:"repo,omitempty"`

	// Tag corresponds to the JSON schema field "tag".
	Tag *Tag `json:"tag,omitempty" yaml:"tag,omitempty" mapstructure:"tag,omitempty"`

	// Version corresponds to the JSON schema field "version".
	Version *Version `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Cosmwasm) UnmarshalJSON(value []byte) error {
	type Plain Cosmwasm
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Path != nil {
		if matched, _ := regexp.MatchString(`^\$HOME.*$`, string(*plain.Path)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "Path", `^\$HOME.*$`)
		}
	}
	if plain.Path != nil && len(*plain.Path) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "path", 1)
	}
	*j = Cosmwasm(plain)
	return nil
}

type Endpoint struct {
	// Address corresponds to the JSON schema field "address".
	Address string `json:"address" yaml:"address" mapstructure:"address"`

	// Archive corresponds to the JSON schema field "archive".
	Archive bool `json:"archive,omitempty" yaml:"archive,omitempty" mapstructure:"archive,omitempty"`

	// Provider corresponds to the JSON schema field "provider".
	Provider *string `json:"provider,omitempty" yaml:"provider,omitempty" mapstructure:"provider,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Endpoint) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["address"]; raw != nil && !ok {
		return fmt.Errorf("field address in Endpoint: required")
	}
	type Plain Endpoint
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.Address) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "address", 1)
	}
	if v, ok := raw["archive"]; !ok || v == nil {
		plain.Archive = false
	}
	if plain.Provider != nil && len(*plain.Provider) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "provider", 1)
	}
	*j = Endpoint(plain)
	return nil
}

type Explorer struct {
	// AccountPage corresponds to the JSON schema field "account_page".
	AccountPage *string `json:"account_page,omitempty" yaml:"account_page,omitempty" mapstructure:"account_page,omitempty"`

	// BlockPage corresponds to the JSON schema field "block_page".
	BlockPage *string `json:"block_page,omitempty" yaml:"block_page,omitempty" mapstructure:"block_page,omitempty"`

	// Kind corresponds to the JSON schema field "kind".
	Kind *string `json:"kind,omitempty" yaml:"kind,omitempty" mapstructure:"kind,omitempty"`

	// ProposalPage corresponds to the JSON schema field "proposal_page".
	ProposalPage *string `json:"proposal_page,omitempty" yaml:"proposal_page,omitempty" mapstructure:"proposal_page,omitempty"`

	// TxPage corresponds to the JSON schema field "tx_page".
	TxPage *string `json:"tx_page,omitempty" yaml:"tx_page,omitempty" mapstructure:"tx_page,omitempty"`

	// Url corresponds to the JSON schema field "url".
	Url *string `json:"url,omitempty" yaml:"url,omitempty" mapstructure:"url,omitempty"`

	// ValidatorPage corresponds to the JSON schema field "validator_page".
	ValidatorPage *string `json:"validator_page,omitempty" yaml:"validator_page,omitempty" mapstructure:"validator_page,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Explorer) UnmarshalJSON(value []byte) error {
	type Plain Explorer
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.AccountPage != nil && len(*plain.AccountPage) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "account_page", 1)
	}
	if plain.BlockPage != nil && len(*plain.BlockPage) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "block_page", 1)
	}
	if plain.Kind != nil && len(*plain.Kind) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "kind", 1)
	}
	if plain.ProposalPage != nil && len(*plain.ProposalPage) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "proposal_page", 1)
	}
	if plain.TxPage != nil && len(*plain.TxPage) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "tx_page", 1)
	}
	if plain.Url != nil && len(*plain.Url) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "url", 1)
	}
	if plain.ValidatorPage != nil && len(*plain.ValidatorPage) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "validator_page", 1)
	}
	*j = Explorer(plain)
	return nil
}

type FeeToken struct {
	// AverageGasPrice corresponds to the JSON schema field "average_gas_price".
	AverageGasPrice *float64 `json:"average_gas_price,omitempty" yaml:"average_gas_price,omitempty" mapstructure:"average_gas_price,omitempty"`

	// Denom corresponds to the JSON schema field "denom".
	Denom string `json:"denom" yaml:"denom" mapstructure:"denom"`

	// FixedMinGasPrice corresponds to the JSON schema field "fixed_min_gas_price".
	FixedMinGasPrice *float64 `json:"fixed_min_gas_price,omitempty" yaml:"fixed_min_gas_price,omitempty" mapstructure:"fixed_min_gas_price,omitempty"`

	// GasCosts corresponds to the JSON schema field "gas_costs".
	GasCosts *FeeTokenGasCosts `json:"gas_costs,omitempty" yaml:"gas_costs,omitempty" mapstructure:"gas_costs,omitempty"`

	// HighGasPrice corresponds to the JSON schema field "high_gas_price".
	HighGasPrice *float64 `json:"high_gas_price,omitempty" yaml:"high_gas_price,omitempty" mapstructure:"high_gas_price,omitempty"`

	// LowGasPrice corresponds to the JSON schema field "low_gas_price".
	LowGasPrice *float64 `json:"low_gas_price,omitempty" yaml:"low_gas_price,omitempty" mapstructure:"low_gas_price,omitempty"`
}

type FeeTokenGasCosts struct {
	// CosmosSend corresponds to the JSON schema field "cosmos_send".
	CosmosSend *float64 `json:"cosmos_send,omitempty" yaml:"cosmos_send,omitempty" mapstructure:"cosmos_send,omitempty"`

	// IbcTransfer corresponds to the JSON schema field "ibc_transfer".
	IbcTransfer *float64 `json:"ibc_transfer,omitempty" yaml:"ibc_transfer,omitempty" mapstructure:"ibc_transfer,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FeeToken) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["denom"]; raw != nil && !ok {
		return fmt.Errorf("field denom in FeeToken: required")
	}
	type Plain FeeToken
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.Denom) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "denom", 1)
	}
	*j = FeeToken(plain)
	return nil
}

type Ibc struct {
	// List of IBC apps (usually corresponding to a ICS standard) which have been
	// enabled on the network.
	IcsEnabled []IbcIcsEnabledElem `json:"ics_enabled,omitempty" yaml:"ics_enabled,omitempty" mapstructure:"ics_enabled,omitempty"`

	// Repo corresponds to the JSON schema field "repo".
	Repo *Repo `json:"repo,omitempty" yaml:"repo,omitempty" mapstructure:"repo,omitempty"`

	// Tag corresponds to the JSON schema field "tag".
	Tag *Tag `json:"tag,omitempty" yaml:"tag,omitempty" mapstructure:"tag,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type IbcType `json:"type" yaml:"type" mapstructure:"type"`

	// Version corresponds to the JSON schema field "version".
	Version *Version `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`
}

type IbcIcsEnabledElem string

const IbcIcsEnabledElemIcs201 IbcIcsEnabledElem = "ics20-1"
const IbcIcsEnabledElemIcs271 IbcIcsEnabledElem = "ics27-1"
const IbcIcsEnabledElemMauth IbcIcsEnabledElem = "mauth"

var enumValues_IbcIcsEnabledElem = []interface{}{
	"ics20-1",
	"ics27-1",
	"mauth",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IbcIcsEnabledElem) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_IbcIcsEnabledElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_IbcIcsEnabledElem, v)
	}
	*j = IbcIcsEnabledElem(v)
	return nil
}

type IbcType string

const IbcTypeGo IbcType = "go"
const IbcTypeOther IbcType = "other"
const IbcTypeRust IbcType = "rust"

var enumValues_IbcType = []interface{}{
	"go",
	"rust",
	"other",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IbcType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_IbcType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_IbcType, v)
	}
	*j = IbcType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Ibc) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in Ibc: required")
	}
	type Plain Ibc
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Ibc(plain)
	return nil
}

type Language struct {
	// Repo corresponds to the JSON schema field "repo".
	Repo *Repo `json:"repo,omitempty" yaml:"repo,omitempty" mapstructure:"repo,omitempty"`

	// Tag corresponds to the JSON schema field "tag".
	Tag *Tag `json:"tag,omitempty" yaml:"tag,omitempty" mapstructure:"tag,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type LanguageType `json:"type" yaml:"type" mapstructure:"type"`

	// Version corresponds to the JSON schema field "version".
	Version *Version `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`
}

type LanguageType string

const LanguageTypeGo LanguageType = "go"
const LanguageTypeOther LanguageType = "other"
const LanguageTypeRust LanguageType = "rust"
const LanguageTypeSolidity LanguageType = "solidity"

var enumValues_LanguageType = []interface{}{
	"go",
	"rust",
	"solidity",
	"other",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LanguageType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LanguageType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LanguageType, v)
	}
	*j = LanguageType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Language) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in Language: required")
	}
	type Plain Language
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Language(plain)
	return nil
}

type Peer struct {
	// Address corresponds to the JSON schema field "address".
	Address string `json:"address" yaml:"address" mapstructure:"address"`

	// Id corresponds to the JSON schema field "id".
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// Provider corresponds to the JSON schema field "provider".
	Provider *string `json:"provider,omitempty" yaml:"provider,omitempty" mapstructure:"provider,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Peer) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["address"]; raw != nil && !ok {
		return fmt.Errorf("field address in Peer: required")
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in Peer: required")
	}
	type Plain Peer
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.Address) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "address", 1)
	}
	if len(plain.Id) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "id", 1)
	}
	if plain.Provider != nil && len(*plain.Provider) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "provider", 1)
	}
	*j = Peer(plain)
	return nil
}

// The (primary) key used to identify an object within the Chain Registry.
type Pointer struct {
	// The base denom of the asset from which the object originates. E.g., when
	// describing ATOM from Cosmos Hub, specify 'uatom', NOT 'atom' nor 'ATOM'; base
	// units are unique per platform.
	BaseDenom *string `json:"base_denom,omitempty" yaml:"base_denom,omitempty" mapstructure:"base_denom,omitempty"`

	// The chain name or platform from which the object resides. E.g., 'cosmoshub',
	// 'ethereum', 'forex', or 'nasdaq'
	ChainName string `json:"chain_name" yaml:"chain_name" mapstructure:"chain_name"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Pointer) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["chain_name"]; raw != nil && !ok {
		return fmt.Errorf("field chain_name in Pointer: required")
	}
	type Plain Pointer
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.BaseDenom != nil && len(*plain.BaseDenom) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "base_denom", 1)
	}
	if len(plain.ChainName) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "chain_name", 1)
	}
	*j = Pointer(plain)
	return nil
}

// URL of the code repository.
type Repo string

// UnmarshalJSON implements json.Unmarshaler.
func (j *Repo) UnmarshalJSON(value []byte) error {
	type Plain Repo
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "", 1)
	}
	*j = Repo(plain)
	return nil
}

type Sdk struct {
	// Repo corresponds to the JSON schema field "repo".
	Repo *Repo `json:"repo,omitempty" yaml:"repo,omitempty" mapstructure:"repo,omitempty"`

	// Tag corresponds to the JSON schema field "tag".
	Tag *Tag `json:"tag,omitempty" yaml:"tag,omitempty" mapstructure:"tag,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type SdkType `json:"type" yaml:"type" mapstructure:"type"`

	// Version corresponds to the JSON schema field "version".
	Version *Version `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`
}

type SdkType string

const SdkTypeCosmos SdkType = "cosmos"
const SdkTypeOther SdkType = "other"
const SdkTypePenumbra SdkType = "penumbra"

var enumValues_SdkType = []interface{}{
	"cosmos",
	"penumbra",
	"other",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SdkType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SdkType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SdkType, v)
	}
	*j = SdkType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Sdk) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in Sdk: required")
	}
	type Plain Sdk
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Sdk(plain)
	return nil
}

type StakingToken struct {
	// Denom corresponds to the JSON schema field "denom".
	Denom string `json:"denom" yaml:"denom" mapstructure:"denom"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StakingToken) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["denom"]; raw != nil && !ok {
		return fmt.Errorf("field denom in StakingToken: required")
	}
	type Plain StakingToken
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.Denom) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "denom", 1)
	}
	*j = StakingToken(plain)
	return nil
}

// Detailed version identifier (e.g., 'v1.0.0-a1s2f43g').
type Tag string

// UnmarshalJSON implements json.Unmarshaler.
func (j *Tag) UnmarshalJSON(value []byte) error {
	type Plain Tag
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^v?\d+(\.\d+){0,2}(-[\w\.\-]+)?$`, string(plain)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "", `^v?\d+(\.\d+){0,2}(-[\w\.\-]+)?$`)
	}
	if len(plain) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "", 1)
	}
	*j = Tag(plain)
	return nil
}

// Simple version string (e.g., 'v1.0.0').
type Version string

// UnmarshalJSON implements json.Unmarshaler.
func (j *Version) UnmarshalJSON(value []byte) error {
	type Plain Version
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^v?\d+(\.\d+){0,2}$`, string(plain)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "", `^v?\d+(\.\d+){0,2}$`)
	}
	if len(plain) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "", 1)
	}
	*j = Version(plain)
	return nil
}
